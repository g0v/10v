# Internatioinalization

 - use i18next and related modules. reference design as in `zbryikt/template`
 - locales files under `locales/<local-name>` folder. files named with corresponding namespace within. e.g., 
   - locales/zh-TW/default.yaml:
     sample text: 範例文字
 - in browser translation - used for dynamic content, if any and only if necessary. 
   - will need additional API for dynamically fetch translation result.
 - compile / render time translation
   - also compile CSS and JS files?
   - files built to lang specific folder with default fallback.
     - dont add source under `intl` subfolder to prevent collision.
     - example
       - default fallback - /static/index.html
       - en version - /static/intl/en/index.html
       - compiled pug - /.view/intl/en/index.html
 - internal resource url or links should use *absolute path*.
   - don't use `base` since it breaks anchor links.
 - on-demand build:
   - nginx looks up for static file first, then turn to express server if missed.
   - express server generates desired files at runtime:
     - compiled js for pug: only i18n key using pug filter are translated.
     - html from pug: all i18n key are translated.



TBD

 * use nginx - serve different html based on user language settings
 * pug replace
 * js replace - special tag and syntax to replace/generate text in html

default en. for static file serving, lookup for <lang>/files.
 * on demand translate

better have a compatible syntax / api with i18next-node, such as: `__("%s cat", 1)` ?

## frontend

Proposal to markup translatable texts.

### use ldView

    doctype html
    html
      body
        q(pd="i18n") some text ...


### simply use css class

    html
      body
        .i18n some text ...


### use obsolete html tag / custom element

    html
      body
        tt some text ...
        i18n some other text ...

## frontend js implementation:

### Vanilla

Pros: no dependency.
Cons: TBD


    Array.from(document.querySelectorAll '.i18n').map -> it.innerText = __(it.textContent)


### ldView

Pros: re-renderable.
Cons: additional dependency

    ldView do
      root: document.body
      global: true
      text: do
        i18n: -> it.innerText = __(it.textContent)


## pug

simply use interpolation such as 

    span #{__("hello world")}

or mixin:

    +i18n("...")


## server 

only need if we have any message directly generated from server. simply use translation function:

    res.send(__("hello world"))


## nginx

On demand static file building triggered by request and handled, cached by nginx.
based on frontend translation yet handled by server-side-rendering.

    /static/index.html:
    <div class="i18n"> some text </div>

    translate to /zh/index.html only if /zh/index.html is older or not exist ( or, always clear static files after deployed ):
    <div> 一些字 </div>



all frontend selector for i18n should not be styled since server-sider rendering may remove related selectors.
on demand build is efficient if nginx could check modifiedtime and trigger building, yet it involves both raw html and  translation files so it may not be as simple as we thought. a manually rebuild of all static file may be more feasible but it's kinda slow if there are too many files.


## directory structure

possible ways: 

 - gltd - e.g., mysite.us ( too expensive )
 - subdomain - e.g., en.mysite.dev 
 - subfolder - e.g., mysite.dev/en ( lower cost. suggested by google market finder )
   - further folder to keep it clear: mysite.dev/intl/en/
 - query params - e.g., mysit.dev/?lang=en ( not recommended by google market finder )

reference: https://marketfinder.thinkwithgoogle.com/intl/en/guide/how-to-approach-i18n/#url-structures

### Subfolder way

for a source pug in /src/pug/index.pug:

 - /static/index.html ( base version )
 - /static/intl/<locale>/index.html ( <locale> version )
   - use <base> to resolve relative path issue.
   - JS also has to be aware of relative path issue.
 - /.view/intl/<locale>/index.js 
 

