// Generated by LiveScript 1.3.1
(function(){
  var fs, fsExtra, pug, LiveScript, stylus, path, browserify, stream, requireReload, aux, pugBuilder, reload, cwd, modpug, modlist, main, slice$ = [].slice;
  fs = require('fs');
  fsExtra = require('fs-extra');
  pug = require('pug');
  LiveScript = require('LiveScript');
  stylus = require('stylus');
  path = require('path');
  browserify = require('browserify');
  stream = require('stream');
  requireReload = require('require-reload');
  aux = require('./aux');
  pugBuilder = require("./pug");
  reload = requireReload(require);
  cwd = path.resolve(process.cwd());
  modpug = {};
  modlist = {};
  main = {
    map: function(list){
      list == null && (list = []);
      return list.filter(function(it){
        return /^src\/mod\/(.+)\/(.+)\//.exec(it);
      }).filter(function(it){
        return /.(ls|styl|pug|png|jpg|gif|svg)$/.exec(it);
      }).map(function(it){
        var des;
        des = path.normalize(it.replace(/^src\/mod/, "static/mod/").replace(/\.pug$/, ".html").replace(/\.ls$/, ".js").replace(/\.styl$/, ".css"));
        return {
          src: it,
          des: des
        };
      });
    },
    meta: function(src){
      var ref$, ref1$, type, id, idx, moreMods, t1, pugfile, metafile, htmlfile, c1, c2, ret, payload;
      ref1$ = [(ref$ = /src\/mod\/([^\/]+)\/([^\/]+)\//.exec(src) || [null, null, null])[1], ref$[2]], type = ref1$[0], id = ref1$[1];
      if (!(type && id)) {
        return;
      }
      if (!modlist[type]) {
        modlist[type] = fs.readdirSync("static/mod/" + type + "/").filter(function(it){
          return !/\.[^\/]+$/.exec(it);
        }).filter(function(it){
          return fs.existsSync("static/mod/" + type + "/" + it + "/meta.json");
        }).map(function(it){
          return JSON.parse(fs.readFileSync("static/mod/" + type + "/" + it + "/meta.json").toString());
        }).map(function(it){
          return {
            id: it.id,
            name: it.name
          };
        });
        modlist[type].sort(function(a, b){
          return Math.round(Math.random()) * 2 - 1;
        });
      }
      idx = Math.floor(Math.random() * (modlist[type].length - 9));
      moreMods = slice$.call(modlist[type], idx, (idx + 8) + 1 || 9e9);
      t1 = Date.now();
      pugfile = "src/pug/asset/" + type + ".pug";
      metafile = "static/mod/" + type + "/" + id + "/meta.json";
      htmlfile = "static/" + type + "/" + id + "/index.html";
      if (fs.existsSync(pugfile) && (!modpug[type] || modpug[type].mtime < fs.statSync(pugfile).mtime)) {
        modpug[type] = {
          mtime: fs.statSync(pugfile).mtime,
          fn: pug.compile(fs.readFileSync(pugfile).toString(), {
            basedir: "src/pug"
          })
        };
      }
      c1 = aux.newer(src, metafile);
      c2 = aux.newer(src, htmlfile) || aux.newer(pugfile, htmlfile);
      if (c1 || c2) {
        fsExtra.ensureDir(path.dirname(htmlfile));
        ret = reload("../../../" + src);
        payload = {
          id: ret.id,
          type: ret.type,
          name: ret.name,
          desc: ret.desc,
          tags: ret.tags,
          slug: ret.slug,
          license: ret.license,
          support: ret.support
        };
        fs.writeFileSync(metafile, JSON.stringify(payload));
        ret = modpug[type].fn({
          mod: payload,
          moreMods: moreMods
        });
        fs.writeFileSync(htmlfile, ret);
        console.log("[BUILD] " + src + " --> " + metafile + " ( ... ) ");
        return console.log("[BUILD] " + src + " --> " + htmlfile + " ( " + (Date.now() - t1) + "ms )");
      }
    },
    build: function(list){
      var this$ = this;
      list = this.map(list);
      list.map(function(arg$){
        var src, des, t1, code, desdir, type, s, bobj, ret, e;
        src = arg$.src, des = arg$.des;
        t1 = Date.now();
        if (aux.newer(des, src)) {
          return;
        }
        try {
          code = fs.readFileSync(src).toString();
          if (/^\/\/- ?(module|view) ?/.exec(code)) {
            return;
          }
          desdir = path.dirname(des);
          fsExtra.ensureDirSync(desdir);
          type = /\.([^.]+)$/.exec(src);
          type = type ? type[1] : void 8;
          if (type === 'ls') {
            code = LiveScript.compile(fs.readFileSync(src).toString(), {
              bare: true
            });
            s = new stream.Readable();
            s.push(code);
            s.push(null);
            bobj = browserify(s, {
              basedir: cwd
            });
            bobj.transform('glslify');
            bobj.bundle(function(e, b){
              if (e) {
                return console.log(e);
              }
              fsExtra.ensureDirSync(path.dirname(des));
              fs.writeFileSync(des, b);
              return console.log("[BUILD] " + src + " --> " + des + " ( " + (Date.now() - t1) + "ms )");
            });
            this$.meta(src);
            return;
          } else if (type === 'styl') {
            ret = stylus(code).set('filename', src).define('index', function(a, b){
              a = (a.string || a.val).split(' ');
              return new stylus.nodes.Unit(a.indexOf(b.val));
            }).render()(function(e, css){});
            fs.writeFileSync(des, ret);
          } else if (type === 'pug') {
            fs.writeFileSync(des, pug.render(code, import$({
              filename: src,
              basedir: path.join(cwd, 'src/pug/')
            }, pugBuilder.extapi)));
          } else if (/png|gif|jpg|svg/.exec(type)) {
            if (aux.newer(des, src)) {
              return;
            }
            fsExtra.copySync(src, des);
            console.log("[COPY ][MOD] " + src + " --> " + des + " ( " + (Date.now() - t1) + "ms )");
            return;
          } else {
            return;
          }
          return console.log("[BUILD][MOD] " + src + " --> " + des + " ( " + (Date.now() - t1) + "ms )");
        } catch (e$) {
          e = e$;
          console.log(("[BUILD][MOD] " + src + " failed: ").red);
          return console.log(e.message.toString().red);
        }
      });
    },
    unlink: function(list){
      var i$, len$, ref$, src, des, results$ = [];
      list = this.map(list);
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
        ref$ = list[i$], src = ref$.src, des = ref$.des;
        if (fs.existsSync(des)) {
          fs.unlinkSync(des);
          results$.push(console.log(("[BUILD][MOD] " + src + " --> " + des + " deleted.").yellow));
        }
      }
      return results$;
    }
  };
  module.exports = main;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
